# 装饰器模式

一、介绍

1. 为对象添加新的功能
2. 不改变原有的结构和功能

二、演示

装饰器代码直接放进浏览器/Node 中运行会报错，因为浏览器和 Node 目前都不支持装饰器语法，需要大家安装 Babel 进行转码：

安装 Babel 及装饰器相关的 Babel 插件

npm install babel-preset-env babel-plugin-transform-decorators-legacy --save-dev
注：在没有任何配置选项的情况下，babel-preset-env 与 babel-preset-latest（或者 babel-preset-es2015，babel-preset-es2016 和 babel-preset-es2017 一起）的行为完全相同。

编写配置文件.babelrc：

{
  "presets": ["env"],
  "plugins": ["transform-decorators-legacy"]
}
最后别忘了下载全局的 Babel 命令行工具用于转码：

npm install babel-cli -g
执行完这波操作，我们首先是对目标文件进行转码，比如说你的目标文件叫做 test.js，想要把它转码后的结果输出到 babel_test.js，就可以这么写:

babel test.js --out-file babel_test.js
运行babel_test.js

babel_test.js
就可以看到你的装饰器是否生效啦~

```js
    class Person {
        constructor(){
            this.first = "A"
            this.last = "B"
        }

        //装饰方法
        @readonly
        name(){
            return `${this.first} ${this.last}`
        }
    }

    let p = new Person()
    console.log(p.name())
    // p.name = function() {} 这里会报错，因为name被修饰后只能可读，不可被修改
    function readonly(target,name,descriptor){
        // target 被修饰的类
        // name 类成员的名字
        // descriptor 属性描述对象（Object.defineProperty 中会用到），原值如下
        // {
        //     value: specifiedFunction,
        //     enumerable: false,
        //     configurable: true,
        //     writable: true
        // }
        descriptor.writable = false;
        return descriptor;
    }
```

三、场景

1. ES7 装饰器
2. core-decorator

四、总结

1. 将现有对象和装饰器进行分离，两者独立存在
2. 符合开放封闭原则

五、装饰器的原理

装饰器本身其实就是一个函数

```js
@decorator
class A{}

//等同于

class A {}
A = decorator(A) || A

// ------------
function testDes(isDec) {
    return function (target) { // 此处返回函数就是装饰器
        target.isDec = isDec
    }
}

@testDes(false)
class Demo {
    //
}
console.log("Demo.isDec===>", Demo.isDec)
```

六、装饰器库

core-decorator

1. 第三方开源 lib
2. 提供常用的装饰器
3. 文档 <https://github.com/jayphelps/core-decorators>
